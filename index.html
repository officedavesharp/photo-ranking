<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A tool by Office D.SHARP to select architectural photographs. Simply click your preferred image in each pair until the process is complete. The algorithm will learn from your choices to create a final ranked set.">
    <title>Photography Selection Tool by Office D.SHARP</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='black'/></svg>">
    <script defer data-domain="officedavesharp.github.io/photo-ranking" src="https://plausible.io/js/script.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f4;
            min-height: 100vh;
        }
        h1 {
            margin-top: 20px;
            margin-bottom: 40px;
        }
        .image-container {
            display: none;
            justify-content: center;
            align-items: center;
            margin: 20px;
            min-height: 750px;
        }
        .image-container img {
            width: auto;
            height: 750px;
            margin: 10px;
            cursor: pointer;
            border: 1px solid transparent;
            object-fit: contain;
        }
        .image-container img:hover {
            border-color: black;
        }
        .link {
            margin-top: 20px;
            text-decoration: none;
            color: #000;
            font-size: 16px;
            text-align: center;
        }
        .link:hover {
            text-decoration: underline;
        }
        .bottom-links {
            position: fixed;
            bottom: 40px;
            display: flex;
            gap: 40px;
            justify-content: center;
            width: 100%;
            left: 0;
        }
        .leaderboard-page {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            max-width: 2200px;
            width: 100%;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: #f4f4f4;
            row-gap: 60px;
            gap: 20px;
        }
        .leaderboard-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            position: relative;
            height: 100%;
            opacity: 0;
            animation: fadeIn 0.3s ease-in forwards;
        }
        .leaderboard-item .image-wrapper {
            width: 100%;
            height: 300px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            background-color: #f4f4f4;
        }
        .leaderboard-item img {
            width: 100%;
            height: auto;
            object-fit: contain;
            max-height: 300px;
            display: block;
            flex-grow: 0;
            background-color: #f4f4f4;
        }
        .leaderboard-item span {
            position: relative;
            font-size: 14px;
            color: black;
            text-align: left;
            width: auto;
            background-color: #f4f4f4;
            padding: 0;
            margin-top: 8px;
        }
        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }
        #progress-percentage {
            display: none;
            position: fixed;
            bottom: 40px;
            right: 40px;
            font-size: 16px;
            color: #000;
        }
        .logo {
            width: 300px;
            height: auto;
            margin: 40px 0 40px 0;
            cursor: pointer;
            position: relative;
            z-index: 2;
        }
        .pdf-layout {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px 20px;
            padding: 40px;
            background-color: white;
            width: 515px;
        }
        .pdf-layout .leaderboard-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background-color: white;
            opacity: 1;
        }
        .pdf-layout .image-container {
            width: 100%;
            position: relative;
            background-color: white;
        }
        .pdf-layout img {
            width: 100%;
            height: auto;
            object-fit: contain;
            background-color: white;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .overlay-content {
            background: white;
            padding: 20px 40px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .custom-file-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 20px;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }
        .custom-file-input input[type="file"] {
            display: none;
        }
        .custom-file-button {
            padding: 10px 20px;
            background-color: black;
            color: white;
            cursor: pointer;
            border: none;
            font-size: 16px;
        }
        .custom-file-button:hover {
            opacity: 0.9;
        }
        .custom-file-label {
            color: #555;
            font-size: 16px;
        }
        .description-text {
            color: #000;
            font-size: 16px;
            text-align: center;
            margin-bottom: 40px;
        }
        .description-text a {
            color: #000;
            text-decoration: underline;
        }
        .initial-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            width: 100%;
            padding: 0 20px;
            box-sizing: border-box;
        }
        .image-container.loading {
            opacity: 0.5;
            pointer-events: none;
        }
        /* Media Queries for responsive grid */
        @media (max-width: 1600px) {
            .leaderboard-page {
                grid-template-columns: repeat(6, 1fr);
                max-width: 1600px;
            }
        }
        @media (max-width: 1200px) {
            .leaderboard-page {
                grid-template-columns: repeat(4, 1fr);
                padding: 30px 15px;
                gap: 30px;
                row-gap: 45px;
            }
        }
        @media (max-width: 768px) {
            .leaderboard-page {
                grid-template-columns: repeat(2, 1fr);
                padding: 20px;
                gap: 20px;
                row-gap: 30px;
                margin-top: 80px;
            }
            .logo {
                width: 200px;
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                margin: 0;
                background: #f4f4f4;
                padding: 10px;
            }
            .bottom-links {
                bottom: 20px;
                gap: 20px;
            }
            .initial-view {
                justify-content: flex-end;
                padding: 0;
                position: relative;
            }
            
            .description-text {
                margin: 0;
                padding: 20px;
                margin-bottom: 80px;
            }
            
            .logo {
                width: 200px;
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                margin: 0;
                background: #f4f4f4;
                padding: 10px;
            }
            
            .custom-file-input {
                margin-bottom: 40px;
            }
            
            .image-container {
                margin: 10px;
                flex-direction: column;
                justify-content: center;
                min-height: auto;
                gap: 10px;
                margin-top: 80px;
            }
            
            .image-container img {
                max-width: 95%;
                max-height: 35vh;
                margin: 5px;
                width: auto;
                height: auto;
                -webkit-tap-highlight-color: transparent;
            }
            
            .bottom-links {
                bottom: 20px;
                gap: 20px;
            }
            
            #progress-percentage {
                bottom: 20px;
                right: 20px;
            }
        }
        @media (max-width: 480px) {
            .leaderboard-page {
                grid-template-columns: 1fr;
                padding: 15px;
                gap: 15px;
                row-gap: 25px;
            }
            .leaderboard-item .image-wrapper {
                height: auto;
                max-height: 400px;
            }
            .bottom-links {
                flex-direction: column;
                gap: 15px;
            }
        }
        /* Remove hover effect on touch devices */
        @media (hover: none) {
            .image-container img:hover {
                border-color: transparent;
            }
        }
    </style>
</head>
<body>
    <div class="initial-view">
        <img src="./static/Office D.SHARP.png" alt="Office D.SHARP" class="logo">
        <div class="custom-file-input">
            <label class="custom-file-button" for="folderInput">Select Images</label>
            <input type="file" id="folderInput" multiple accept="image/*" />
        </div>
        <div style="flex-grow: 1"></div>
        <div class="description-text">
            A tool by <a href="https://www.officedavesharp.com/" target="_blank" rel="noopener">Office D.SHARP</a> to select architectural photographs. Simply click your preferred image in each pair until the process is complete. The algorithm will learn from your choices to create a final ranked set.
        </div>
    </div>
    <div class="image-container" id="image-container" style="display: none;">
        <img id="image1" src="" alt="Image 1" loading="lazy" style="display: none;">
        <img id="image2" src="" alt="Image 2" loading="lazy" style="display: none;">
    </div>
    <div id="progress-percentage">0%</div>
    <div class="bottom-links">
        <a href="#" class="link" id="view-leaderboard" style="display: none;">View Leaderboard</a>
    </div>

    <script>
        const images = [];
        const rankings = {};
        let currentPair = [];
        let nextPair = [];
        let nextPairElements = [];
        let comparisons = 0;
        let totalComparisons = 0; // Will be set dynamically
        let lastShownImages = new Set();
        const K_FACTOR = 32;
        let firstThresholdReached = false;
        let currentImageUrls = new Set(); // To track created URLs for cleanup
        let isLoading = false;
        const fileNames = new Map(); // To store original file names
        const gamesPlayed = new Map();      // Track number of comparisons per image
        const ratingConfidence = new Map();  // Track rating confidence
        const matchHistory = new Map();      // Track win/loss history
        const ratingVolatility = new Map();  // Track rating changes

        // Add this right after your variable declarations, before any other functions
        function resetSession() {
            isLoading = false;
            // Clean up object URLs
            currentImageUrls.forEach(url => {
                try {
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Error revoking URL:', error);
                }
            });
            currentImageUrls.clear();
            fileNames.clear(); // Clear stored filenames
            
            // Clear all data including new tracking maps
            images.length = 0;
            Object.keys(rankings).forEach(key => delete rankings[key]);
            gamesPlayed.clear();
            ratingConfidence.clear();
            matchHistory.clear();
            ratingVolatility.clear();
            currentPair = [];
            nextPair = [];
            nextPairElements = [];
            comparisons = 0;
            totalComparisons = 0;
            lastShownImages.clear();
            firstThresholdReached = false;
            
            // Reset UI to initial state
            document.body.innerHTML = `
                <div class="initial-view">
                    <img src="./static/Office D.SHARP.png" alt="Office D.SHARP" class="logo">
                    <div class="custom-file-input">
                        <label class="custom-file-button" for="folderInput">Select Images</label>
                        <input type="file" id="folderInput" multiple accept="image/*" />
                    </div>
                    <div style="flex-grow: 1"></div>
                    <div class="description-text">
                        A tool by <a href="https://www.officedavesharp.com/" target="_blank" rel="noopener">Office D.SHARP</a> to rank architectural photographs. Simply click your preferred image in each pair until the process is complete. The algorithm will learn from your choices to create a ranked list from most to least preferred.
                    </div>
                </div>
                <div class="image-container" id="image-container" style="display: none;">
                    <img id="image1" src="" alt="Image 1" loading="lazy" style="display: none;">
                    <img id="image2" src="" alt="Image 2" loading="lazy" style="display: none;">
                </div>
                <div id="progress-percentage">0%</div>
                <div class="bottom-links">
                    <a href="#" class="link" id="view-leaderboard" style="display: none;">View Leaderboard</a>
                </div>
            `;
            
            // Reattach event listener for file input
            document.getElementById('folderInput').addEventListener('change', async (event) => {
                await handleFileInput(event);
            });
        }

        // Add this new function to calculate optimal comparisons
        function calculateOptimalComparisons(imageCount) {
            let comparisonsPerImage;
            if (imageCount <= 30) {
                comparisonsPerImage = 6;     // Reduced from 10
            } else if (imageCount <= 60) {
                comparisonsPerImage = 5;     // Reduced from 8
            } else if (imageCount <= 100) {
                comparisonsPerImage = 4;     // Reduced from 6
            } else {
                comparisonsPerImage = 3;     // Reduced from 5
            }
            return Math.round((imageCount * comparisonsPerImage) / 2);
        }

        // Function to preload images
        function preloadImages(srcArray, callback) {
            let loadedCount = 0;
            const imgElements = [];

            srcArray.forEach((src, index) => {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    loadedCount++;
                    imgElements[index] = img;
                    if (loadedCount === srcArray.length) {
                        callback(imgElements);
                    }
                };
            });
        }

        // Function to calculate new ratings
        function calculateNewRatings(winner, loser) {
            const winnerRating = rankings[winner] || 1500;
            const loserRating = rankings[loser] || 1500;
            const winnerGames = (gamesPlayed.get(winner) || 0) + 1;
            const loserGames = gamesPlayed.get(loser) || 0 + 1;
            
            // Calculate K-factor based on games played and current rating
            const winnerK = winnerGames < 10 ? 40 : (winnerRating < 1500 ? 32 : 24);
            const loserK = loserGames < 10 ? 40 : (loserRating < 1500 ? 32 : 24);
            
            // Calculate expected scores
            const expectedWinner = 1 / (1 + Math.pow(10, (loserRating - winnerRating) / 400));
            const expectedLoser = 1 - expectedWinner;
            
            // Update ratings
            const newWinnerRating = Math.round(winnerRating + winnerK * (1 - expectedWinner));
            const newLoserRating = Math.round(loserRating + loserK * (0 - expectedLoser));
            
            // Update volatility
            updateVolatility(winner, winnerRating, newWinnerRating);
            updateVolatility(loser, loserRating, newLoserRating);
            
            // Update confidence scores
            const winnerConfidence = ratingConfidence.get(winner) || 0;
            const loserConfidence = ratingConfidence.get(loser) || 0;
            ratingConfidence.set(winner, winnerConfidence + Math.abs(1 - expectedWinner));
            ratingConfidence.set(loser, loserConfidence + Math.abs(0 - expectedLoser));
            
            // Update match history
            updateMatchHistory(winner, loser);
            
            // Update games played
            gamesPlayed.set(winner, winnerGames);
            gamesPlayed.set(loser, loserGames);
            
            // Finally, update rankings
            rankings[winner] = newWinnerRating;
            rankings[loser] = newLoserRating;
        }

        // Add helper functions for the improved algorithm
        function updateVolatility(image, oldRating, newRating) {
            const volatility = ratingVolatility.get(image) || [];
            volatility.push(Math.abs(newRating - oldRating));
            if (volatility.length > 5) volatility.shift(); // Keep last 5 changes
            ratingVolatility.set(image, volatility);
        }

        function updateMatchHistory(winner, loser) {
            const winnerHistory = matchHistory.get(winner) || [];
            const loserHistory = matchHistory.get(loser) || [];
            
            winnerHistory.push(1);
            loserHistory.push(0);
            
            // Keep last 10 matches
            if (winnerHistory.length > 10) winnerHistory.shift();
            if (loserHistory.length > 10) loserHistory.shift();
            
            matchHistory.set(winner, winnerHistory);
            matchHistory.set(loser, loserHistory);
        }

        function getRecentPerformance(image) {
            const history = matchHistory.get(image) || [];
            if (history.length === 0) return 0.5;
            
            return history.reduce((acc, result, index) => 
                acc + result * (1 + index/history.length)
            ) / history.length;
        }

        // Update the selectNextPair function to prevent duplicate images
        function selectNextPair() {
            if (images.length < 2) {
                console.error('Not enough images to select a pair');
                return null;
            }

            // Get all available images that aren't in lastShownImages
            const availableImages = images.filter(img => !lastShownImages.has(img));
            if (availableImages.length < 2) {
                lastShownImages.clear();
                return selectNextPair();
            }

            // Strongly prioritize unranked images
            const unrankedImages = availableImages.filter(img => !(img in rankings));
            if (unrankedImages.length >= 2) {
                // If we have at least 2 unranked images, use them
                const firstIndex = Math.floor(Math.random() * unrankedImages.length);
                const first = unrankedImages[firstIndex];
                // Remove the first image from consideration for the second
                const remainingUnranked = unrankedImages.filter((_, index) => index !== firstIndex);
                const second = remainingUnranked[Math.floor(Math.random() * remainingUnranked.length)];
                
                const pair = [first, second];
                pair.forEach(img => lastShownImages.add(img));
                return pair;
            } else if (unrankedImages.length === 1) {
                // If we have 1 unranked image, pair it with a ranked one
                const rankedImages = availableImages.filter(img => 
                    img in rankings && img !== unrankedImages[0]  // Ensure different from first image
                );
                if (rankedImages.length === 0) {
                    return selectNextPair(); // Try again if no valid pairs
                }
                const pair = [
                    unrankedImages[0],
                    rankedImages[Math.floor(Math.random() * rankedImages.length)]
                ];
                pair.forEach(img => lastShownImages.add(img));
                return pair;
            }

            // Calculate scores for each image based on multiple factors
            const imageScores = availableImages.map(img => ({
                image: img,
                rating: rankings[img] || 1500,
                confidence: ratingConfidence.get(img) || 0,
                gamesPlayed: gamesPlayed.get(img) || 0,
                performance: getRecentPerformance(img),
                score: 0
            }));

            // Calculate priority scores
            imageScores.forEach(img => {
                img.score += (1 - (img.confidence / (averageConfidence() || 1))) * 3;
                img.score += (10 - Math.min(img.gamesPlayed, 10)) * 2;
                img.score += Math.random();
            });

            // Sort by score and select first image
            imageScores.sort((a, b) => b.score - a.score);
            const firstImage = imageScores[0].image;

            // Find a suitable opponent (excluding the first image)
            const remainingImages = imageScores
                .slice(1)
                .filter(img => img.image !== firstImage);  // Extra safety check

            if (remainingImages.length === 0) {
                return selectNextPair(); // Try again if no valid pairs
            }

            const targetRating = rankings[firstImage] || 1500;

            // Score potential opponents
            remainingImages.forEach(img => {
                const ratingDiff = Math.abs(img.rating - targetRating);
                img.score = 100 - Math.min(ratingDiff / 10, 100);
                img.score += Math.random() * 20;
            });

            // Select opponent
            remainingImages.sort((a, b) => b.score - a.score);
            const secondImage = remainingImages[0].image;

            // Final validation
            if (firstImage === secondImage) {
                console.error('Attempted to create pair with same image');
                return selectNextPair(); // Try again if somehow got same image
            }

            const selectedPair = [firstImage, secondImage];
            selectedPair.forEach(img => lastShownImages.add(img));

            return selectedPair;
        }

        // Add this helper function at the top of your script section
        function loadImageWithRetry(src, maxRetries = 3, delay = 1000) {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                
                function attemptLoad() {
                    attempts++;
                    const img = new Image();
                    
                    let timeoutId = setTimeout(() => {
                        console.warn(`Image load timeout on attempt ${attempts}`);
                        img.onerror(new Error('Timeout'));
                    }, 10000); // 10 second timeout
                    
                    img.onload = () => {
                        clearTimeout(timeoutId);
                        resolve(img);
                    };
                    
                    img.onerror = (error) => {
                        clearTimeout(timeoutId);
                        console.warn(`Attempt ${attempts} failed to load image:`, src, error);
                        if (attempts < maxRetries) {
                            setTimeout(attemptLoad, delay * attempts); // Increasing delay with each attempt
                        } else {
                            reject(new Error(`Failed to load image after ${maxRetries} attempts`));
                        }
                    };
                    
                    try {
                        img.src = src;
                    } catch (error) {
                        clearTimeout(timeoutId);
                        reject(error);
                    }
                }
                
                attemptLoad();
            });
        }

        // Update the loadRandomPair function
        function loadRandomPair(callback) {
            if (isLoading) {
                console.warn('Already loading images, skipping this request');
                return;
            }
            
            const selectedPair = selectNextPair();
            
            if (!selectedPair || selectedPair.length !== 2) {
                console.error('Invalid pair selected:', selectedPair);
                return;
            }
            
            isLoading = true;
            
            Promise.all([
                loadImageWithRetry(selectedPair[0]),
                loadImageWithRetry(selectedPair[1])
            ])
            .then(([img1, img2]) => {
                nextPair = selectedPair;
                nextPairElements = [img1, img2];
                isLoading = false;
                if (callback) callback();
            })
            .catch(error => {
                console.error('Error in loadRandomPair:', error);
                isLoading = false;
                
                // Try one more time with a new pair
                const newPair = selectNextPair();
                if (newPair && newPair.length === 2) {
                    isLoading = true;
                    Promise.all([
                        loadImageWithRetry(newPair[0]),
                        loadImageWithRetry(newPair[1])
                    ])
                    .then(([img1, img2]) => {
                        nextPair = newPair;
                        nextPairElements = [img1, img2];
                        isLoading = false;
                        if (callback) callback();
                    })
                    .catch(error => {
                        console.error('Failed to load images after retry:', error);
                        isLoading = false;
                        alert('Error loading images. Please try again.');
                        resetSession();
                    });
                }
            });
        }

        // Update the displayNextPair function
        function displayNextPair() {
            if (isLoading) {
                console.warn('Already loading images, waiting...');
                setTimeout(() => displayNextPair(), 500);
                return;
            }
            
            if (nextPair.length === 0 || nextPairElements.length === 0) {
                console.error('No next pair available');
                return;
            }
            
            const img1 = document.getElementById('image1');
            const img2 = document.getElementById('image2');
            const container = document.getElementById('image-container');
            
            if (!img1 || !img2 || !container) {
                console.error('Required elements not found');
                return;
            }
            
            isLoading = true;
            
            // Hide current images while loading new ones
            img1.style.display = 'none';
            img2.style.display = 'none';
            
            // Ensure container is visible
            container.style.display = 'flex';
            
            Promise.all([
                loadImageWithRetry(nextPairElements[0].src),
                loadImageWithRetry(nextPairElements[1].src)
            ])
            .then(([loadedImg1, loadedImg2]) => {
                currentPair = nextPair;
                img1.src = loadedImg1.src;
                img2.src = loadedImg2.src;
                
                // Show images only after both are loaded
                requestAnimationFrame(() => {
                    img1.style.display = 'block';
                    img2.style.display = 'block';
                    isLoading = false;
                    
                    // Start loading next pair only after current pair is displayed
                    loadRandomPair();
                });
            })
            .catch(error => {
                console.error('Error in displayNextPair:', error);
                isLoading = false;
                alert('Error loading images. Please try again.');
                resetSession();
            });
        }

        // Update the handleFileInput function to be async
        async function handleFileInput(event) {
            const files = event.target.files;
            const maxSize = 20 * 1024 * 1024; // 20MB in bytes
            
            // Clean up any existing object URLs
            currentImageUrls.forEach(url => {
                try {
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Error revoking URL:', error);
                }
            });
            currentImageUrls.clear();
            images.length = 0;
            
            try {
                if (!files || files.length < 2) {
                    alert('Please select at least 2 images.');
                    return;
                }

                // Check for large files first
                const largeFiles = Array.from(files).filter(file => 
                    file.type.startsWith('image/') && file.size > maxSize
                );

                if (largeFiles.length > 0) {
                    alert(`${largeFiles.length} image${largeFiles.length > 1 ? 's' : ''} exceed${largeFiles.length === 1 ? 's' : ''} the 20MB size limit.\nPlease select smaller images.`);
                    document.getElementById('folderInput').value = ''; // Clear the input
                    return;
                }

                // Validate files
                const validFiles = Array.from(files).filter(file => {
                    if (!file.type.startsWith('image/')) {
                        console.warn('Skipping non-image file:', file.name);
                        return false;
                    }
                    return true;
                });

                if (validFiles.length < 2) {
                    alert('Please select at least 2 valid image files.');
                    return;
                }

                // Create object URLs for valid files
                validFiles.forEach(file => {
                    try {
                        const url = URL.createObjectURL(file);
                        currentImageUrls.add(url);
                        images.push(url);
                        fileNames.set(url, file.name); // Store the original filename
                    } catch (error) {
                        console.error('Error creating object URL for file:', file.name, error);
                    }
                });

                if (images.length < 2) {
                    throw new Error('Failed to process enough valid images');
                }

                // Set the total comparisons based on image count
                totalComparisons = calculateOptimalComparisons(images.length);
                
                // Remove initial view and show ranking interface
                document.querySelector('.initial-view').style.display = 'none';
                
                // Add logo back
                const logo = document.createElement('img');
                logo.src = './static/Office D.SHARP.png';
                logo.alt = 'Office D.SHARP';
                logo.className = 'logo';
                logo.onclick = resetSession;
                document.body.insertBefore(logo, document.body.firstChild);
                
                // Show container and leaderboard link
                const container = document.getElementById('image-container');
                container.style.display = 'flex';
                document.getElementById('view-leaderboard').style.display = 'block';
                document.getElementById('progress-percentage').style.display = 'block';  // Show progress
                
                // Preload first pair of images before displaying
                const firstPair = selectNextPair();
                if (!firstPair) {
                    throw new Error('Failed to select initial pair of images');
                }
                
                isLoading = true;
                
                try {
                    await loadInitialImages(firstPair);
                    isLoading = false;
                } catch (error) {
                    console.error('Failed to load initial images after all attempts:', error);
                    alert('Unable to load images. Please try again.');
                    isLoading = false;
                    resetSession();
                    return;
                }
            } catch (error) {
                console.error('Error in handleFileInput:', error);
                alert('An error occurred while processing the images. Please try again.');
                resetSession();
            }
        }

        // Update the event listener to handle async function
        document.getElementById('folderInput').addEventListener('change', async (event) => {
            await handleFileInput(event);
        });

        // Function to update progress percentage
        function updateProgress() {
            const progress = Math.min((comparisons / totalComparisons) * 100, 100);
            document.getElementById('progress-percentage').innerText = `${Math.floor(progress)}%`;
        }

        // Add early completion check based on rating stability
        function checkRatingStability() {
            // If we've done at least 70% of planned comparisons, check if ratings are stable
            if (comparisons >= totalComparisons * 0.7) {
                const volatilities = Array.from(ratingVolatility.values());
                if (volatilities.length > 0) {
                    // Calculate average recent volatility
                    const avgVolatility = volatilities.reduce((sum, vol) => 
                        sum + (vol.length > 0 ? vol[vol.length - 1] : 0), 0
                    ) / volatilities.length;
                    
                    // If average volatility is low, consider rankings stable
                    if (avgVolatility < 15) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Update handleImageClick to include early completion
        function handleImageClick(selectedImage) {
            if (isLoading) {
                console.warn('Images are still loading, ignoring click');
                return;
            }
            
            const otherImage = currentPair.find(img => img !== selectedImage);
            calculateNewRatings(selectedImage, otherImage);
            comparisons++;
            updateProgress();
            
            // Check if we should complete early
            if ((comparisons >= totalComparisons && !firstThresholdReached) || 
                (checkRatingStability() && !firstThresholdReached)) {
                firstThresholdReached = true;
                showLeaderboard();
            } else {
                if (nextPair.length === 0 || nextPairElements.length === 0) {
                    loadRandomPair(() => displayNextPair());
                } else {
                    displayNextPair();
                }
            }
        }

        // Event listeners
        function attachEventListeners() {
            const img1 = document.getElementById('image1');
            const img2 = document.getElementById('image2');
            
            if (!img1 || !img2) {
                console.error('Image elements not found!');
                return;
            }
            
            // Handle both click and touch events
            const addImageListeners = (img, pairIndex) => {
                const handler = (e) => {
                    e.preventDefault();
                    if (!isLoading) {
                        handleImageClick(currentPair[pairIndex]);
                    }
                };
                
                img.addEventListener('click', handler);
                img.addEventListener('touchend', handler);
            };
            
            addImageListeners(img1, 0);
            addImageListeners(img2, 1);
            
            // Prevent default touch behavior
            img1.addEventListener('touchstart', (e) => e.preventDefault());
            img2.addEventListener('touchstart', (e) => e.preventDefault());
        }

        attachEventListeners();

        // Function to preload leaderboard images
        function preloadLeaderboardImages(imageUrls, batchSize = 14) { // 2 rows worth of images
            return new Promise((resolve) => {
                const batches = [];
                for (let i = 0; i < imageUrls.length; i += batchSize) {
                    batches.push(imageUrls.slice(i, i + batchSize));
                }
                resolve(batches);
            });
        }

        // Update the leaderboard click handler
        document.getElementById('view-leaderboard').addEventListener('click', (e) => {
            e.preventDefault();
            showLeaderboard();
        });

        // Add this new function to create thumbnails
        function createThumbnail(imageUrl, maxWidth = 300, quality = 0.7) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate dimensions while preserving aspect ratio
                    const ratio = img.width / img.height;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxWidth) {
                        width = maxWidth;
                        height = width / ratio;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', quality));
                };
                img.onerror = () => resolve(imageUrl);
                img.src = imageUrl;
            });
        }

        // Update the showLeaderboard function
        async function showLeaderboard() {
            debugRankings();
            
            // Show loading overlay
            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            overlay.innerHTML = `
                <div class="overlay-content">
                    Loading Leaderboard
                </div>
            `;
            document.body.appendChild(overlay);

            try {
                const body = document.body;
                body.innerHTML = `
                    <img src="./static/Office D.SHARP.png" alt="Office D.SHARP" class="logo" onclick="restoreRankingPage()">
                    <div class="leaderboard-page"></div>
                `;
                
                // Re-add the overlay since we just overwrote the body
                document.body.appendChild(overlay);
                
                const container = document.querySelector('.leaderboard-page');
                const sortedImages = Object.keys(rankings).sort((a, b) => rankings[b] - rankings[a]);
                
                // First, create all thumbnails
                const thumbnailPromises = sortedImages.map(image => 
                    createThumbnail(image, 300, 0.85)
                );
                
                // Wait for all thumbnails to be created
                const thumbnails = await Promise.all(thumbnailPromises);
                
                // Create and load all items with their thumbnails
                const loadPromises = thumbnails.map((thumbnail, index) => {
                    return new Promise(resolve => {
                        const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        item.style.opacity = '0'; // Start hidden
                        
                        const imageWrapper = document.createElement('div');
                        imageWrapper.className = 'image-wrapper';
                        
                        const img = new Image();
                        const span = document.createElement('span');
                        span.textContent = (index + 1).toString();
                        
                        // Get the original filename from our Map
                        const originalUrl = sortedImages[index];
                        const fileName = fileNames.get(originalUrl) || 'Unknown file';
                        img.alt = fileName;
                        img.title = fileName; // Also add title for tooltip
                        
                        img.onload = resolve;
                        img.src = thumbnail;
                        
                        imageWrapper.appendChild(img);
                        item.appendChild(imageWrapper);
                        item.appendChild(span);
                        container.appendChild(item);
                    });
                });
                
                // Wait for all images to load
                await Promise.all(loadPromises);
                
                // Show all items with fade in
                document.querySelectorAll('.leaderboard-item').forEach(item => {
                    item.style.opacity = '1';
                    item.style.transition = 'opacity 0.3s ease-in';
                });
                
                // Add bottom links after images are loaded
                const bottomLinks = document.createElement('div');
                bottomLinks.className = 'bottom-links';
                bottomLinks.innerHTML = `
                    <a href="#" class="link" id="back-link">Continue Ranking</a>
                    <a href="#" class="link" id="download-pdf">Download PDF</a>
                `;
                document.body.appendChild(bottomLinks);
                
                // Add event listeners
                document.getElementById('back-link').addEventListener('click', (e) => {
                    e.preventDefault();
                    window.restoreRankingPage();
                });
                
                document.getElementById('download-pdf').addEventListener('click', (e) => {
                    e.preventDefault();
                    generatePDF();
                });
                
                // Remove loading overlay only after everything is ready
                document.body.removeChild(overlay);
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                document.body.removeChild(overlay);
            }
        }

        // Update restoreRankingPage function
        window.restoreRankingPage = function() {
            document.body.innerHTML = `
                <img src="./static/Office D.SHARP.png" alt="Office D.SHARP" class="logo" onclick="resetSession()">
                <div class="image-container" id="image-container">
                    <img id="image1" src="" alt="Image 1" loading="lazy" style="display: none;">
                    <img id="image2" src="" alt="Image 2" loading="lazy" style="display: none;">
                </div>
                <div id="progress-percentage">${Math.floor((comparisons / totalComparisons) * 100)}%</div>
                <div class="bottom-links">
                    <a href="#" class="link" id="view-leaderboard">View Leaderboard</a>
                </div>
            `;
            
            // Reattach event listeners
            attachEventListeners();
            document.getElementById('view-leaderboard').addEventListener('click', (e) => {
                e.preventDefault();
                showLeaderboard();
            });

            // Show container but keep images hidden until loaded
            document.getElementById('image-container').style.display = 'flex';
            document.getElementById('view-leaderboard').style.display = 'block';
            
            if (currentPair.length === 2) {
                nextPair = currentPair;
                nextPairElements = currentPair.map(src => {
                    const img = new Image();
                    img.src = src;
                    return img;
                });
                displayNextPair();
            } else {
                loadRandomPair(() => {
                    displayNextPair();
                });
            }
        };

        // Update the generatePDF function to fix PDF generation
        async function generatePDF() {
            // Show overlay
            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            overlay.innerHTML = `
                <div class="overlay-content">
                    Generating PDF
                </div>
            `;
            document.body.appendChild(overlay);

            try {
                const { jsPDF } = window.jspdf;
                if (!jsPDF) {
                    console.error('jsPDF not loaded');
                    return;
                }

                const pdfDiv = document.createElement('div');
                pdfDiv.className = 'pdf-layout';
                pdfDiv.style.position = 'absolute';
                pdfDiv.style.left = '-9999px';
                pdfDiv.style.backgroundColor = 'white';
                document.body.appendChild(pdfDiv);
                
                const sortedImages = Object.keys(rankings).sort((a, b) => rankings[b] - rankings[a]);
                const doc = new jsPDF('p', 'pt', 'a4');
                
                // A4 dimensions and margins
                const pageWidth = 595;
                const pageHeight = 842;
                const margin = 40;
                const bottomMargin = 60; // Increased bottom margin
                const contentWidth = pageWidth - (2 * margin);
                
                // Logo setup
                const logo = document.querySelector('.logo');
                const logoRatio = logo.naturalWidth / logo.naturalHeight;
                const logoWidth = 200;
                const logoHeight = logoWidth / logoRatio;
                const logoX = (pageWidth - logoWidth) / 2;
                const topMargin = 45; // Increased top margin for logo
                
                // Items per page calculation (3 rows of 3 for first page, 3 rows for others)
                const itemsPerFirstPage = 9;
                const itemsPerOtherPage = 9;
                const pages = Math.ceil((sortedImages.length - itemsPerFirstPage) / itemsPerOtherPage) + 1;
                
                for (let page = 0; page < pages; page++) {
                    if (page > 0) doc.addPage();
                    
                    // Only add logo on first page
                    if (page === 0) {
                        doc.addImage(logo.src, 'PNG', logoX, topMargin, logoWidth, logoHeight);
                    }
                    
                    pdfDiv.innerHTML = '';
                    const startIndex = page === 0 ? 0 : itemsPerFirstPage + (page - 1) * itemsPerOtherPage;
                    const itemsThisPage = page === 0 ? itemsPerFirstPage : itemsPerOtherPage;
                    const pageImages = sortedImages.slice(startIndex, startIndex + itemsThisPage);
                    
                    // Create all thumbnails for this page with higher quality
                    const thumbnails = await Promise.all(
                        pageImages.map(img => createThumbnail(img, 800, 1.0))
                    );
                    
                    thumbnails.forEach((thumbnail, i) => {
                        const itemNumber = startIndex + i + 1;
                        const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        item.style.backgroundColor = 'white';
                        item.innerHTML = `
                            <div style="width: 100%; background-color: white; display: flex; flex-direction: column; align-items: flex-start;">
                                <div style="width: 100%; height: 225px; display: flex; align-items: flex-start; justify-content: center; background-color: white;">
                                    <img src="${thumbnail}" alt="Image" 
                                        style="max-width: 100%; max-height: 225px; width: auto; height: auto; object-fit: contain; background-color: white; display: block;">
                                </div>
                                <div style="width: 100%; padding: 0; margin-top: -3px; background-color: white;">
                                    <span style="font-size: 12px; line-height: 14px; font-family: Arial, sans-serif; color: black; background-color: white; display: block;">
                                        ${itemNumber}
                                    </span>
                                </div>
                            </div>
                        `;
                        pdfDiv.appendChild(item);
                    });
                    
                    const yOffset = page === 0 ? logoHeight + topMargin : margin;
                    
                    const canvas = await html2canvas(pdfDiv, {
                        backgroundColor: 'white',
                        scale: 4,
                        logging: false,
                        useCORS: true,
                        imageTimeout: 0,
                        removeContainer: true,
                        allowTaint: false,
                        foreignObjectRendering: false,
                        onclone: function(clonedDoc) {
                            const images = clonedDoc.getElementsByTagName('img');
                            for(let img of images) {
                                // Reset any transforms or positioning
                                img.style.transform = 'none';
                                img.style.position = 'static';
                                img.style.display = 'block';
                                
                                // Let the image size itself naturally within its container
                                img.style.maxWidth = '100%';
                                img.style.maxHeight = '300px';
                                img.style.width = 'auto';
                                img.style.height = 'auto';
                                img.style.objectFit = 'contain';
                            }
                        }
                    });
                    
                    // Add the image at full content width
                    doc.addImage(
                        canvas.toDataURL('image/jpeg', 1.0),
                        'JPEG',
                        margin,
                        yOffset,
                        contentWidth,
                        (contentWidth * canvas.height) / canvas.width,
                        '',
                        'FAST',
                        0
                    );
                }
                
                doc.save('leaderboard.pdf');
                document.body.removeChild(pdfDiv);
            } catch (error) {
                console.error('PDF generation error:', error);
            } finally {
                document.body.removeChild(overlay);
            }
        }

        // Add resetSession function
        window.resetSession = resetSession;

        // Add this new function at the top of your script section
        async function loadInitialImages(firstPair, maxAttempts = 3) {
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    console.log(`Attempt ${attempt} to load initial images`);
                    
                    // Clear any existing state
                    currentPair = [];
                    nextPair = [];
                    nextPairElements = [];
                    
                    const loadedImages = await Promise.all([
                        loadImageWithRetry(firstPair[0], 3, 800),  // Increased retries and delay
                        loadImageWithRetry(firstPair[1], 3, 800)
                    ]);
                    
                    const img1 = document.getElementById('image1');
                    const img2 = document.getElementById('image2');
                    
                    if (!img1 || !img2) {
                        throw new Error('Image elements not found');
                    }
                    
                    // Set current pair before setting sources
                    currentPair = firstPair;
                    
                    // Set sources and wait for them to load
                    await Promise.all([
                        new Promise((resolve, reject) => {
                            img1.onload = resolve;
                            img1.onerror = reject;
                            img1.src = loadedImages[0].src;
                        }),
                        new Promise((resolve, reject) => {
                            img2.onload = resolve;
                            img2.onerror = reject;
                            img2.src = loadedImages[1].src;
                        })
                    ]);
                    
                    // Show images only after both are fully loaded
                    img1.style.display = 'block';
                    img2.style.display = 'block';
                    
                    // Start loading next pair
                    loadRandomPair();
                    
                    // Attach event listeners
                    attachEventListeners();
                    
                    return true; // Success
                } catch (error) {
                    console.error(`Attempt ${attempt} failed:`, error);
                    
                    if (attempt === maxAttempts) {
                        throw error; // Re-throw if all attempts failed
                    }
                    
                    // Wait before retrying
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }

        // Add this helper function
        function averageConfidence() {
            if (ratingConfidence.size === 0) return 0;
            const sum = Array.from(ratingConfidence.values()).reduce((a, b) => a + b, 0);
            return sum / ratingConfidence.size;
        }

        // Add this debug function
        function debugRankings() {
            console.log('Total images loaded:', images.length);
            console.log('Images in rankings:', Object.keys(rankings).length);
            console.log('Images in gamesPlayed:', gamesPlayed.size);
            console.log('Images in matchHistory:', matchHistory.size);
            
            // Find images that aren't in rankings
            const unrankedImages = images.filter(img => !(img in rankings));
            console.log('Unranked images:', unrankedImages.length);
            
            // Check if any images have no games played
            const noGamesPlayed = images.filter(img => !gamesPlayed.has(img));
            console.log('Images with no games:', noGamesPlayed.length);
        }
    </script>
</body>
</html>
